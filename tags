!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
AVISO	imagem.h	36;"	d
BACK_GROUND	cores.h	21;"	d
BLUE	imagem.h	/^    BLUE  \/* = 2 *\/$/;"	e	enum:cores
Bool	imagem.h	/^typedef Byte Bool;$/;"	t
Byte	imagem.h	/^typedef unsigned char Byte;$/;"	t
CC	Makefile	/^CC     = gcc$/;"	m
CFLAGS	Makefile	/^CFLAGS = -Wall -O2 -std=c99 -pedantic -Wno-unused-result -Wno-deprecated-declarations$/;"	m
CelPixel	imagem.h	/^typedef struct celPixel CelPixel;$/;"	t	typeref:struct:celPixel
CelRegiao	imagem.h	/^typedef struct celRegiao CelRegiao;$/;"	t	typeref:struct:celRegiao
Color	imagem.h	/^typedef Byte Color; $/;"	t
DEBUG	graphic.c	38;"	d	file:
DEBUG_CARREGA	io.c	38;"	d	file:
DEBUG_COR	io.c	39;"	d	file:
ERRO	imagem.h	37;"	d
EXIT_FAILURE_MALLOC	imagem.c	46;"	d	file:
FALSE	imagem.h	/^    FALSE \/* = 0 *\/,$/;"	e	enum:bool
GLLIB	Makefile	/^	GLLIB = -framework OpenGL -framework GLUT -framework Cocoa$/;"	m
GLLIB	Makefile	/^	GLLIB = -lGL -lGLU -lglut$/;"	m
GREEN	imagem.h	/^    GREEN \/* = 1 *\/,$/;"	e	enum:cores
Imagem	imagem.h	/^typedef struct imagem Imagem;$/;"	t	typeref:struct:imagem
LIMIAR	imagem.h	40;"	d
MAX_NOME	io.c	48;"	d	file:
MAX_NOME	main.c	44;"	d	file:
MAX_NOME	main.c	45;"	d	file:
NORMA	imagem.c	51;"	d	file:
NUM_CORES	cores.h	18;"	d
Pixel	imagem.h	/^typedef struct pixel Pixel;$/;"	t	typeref:struct:pixel
RED	imagem.h	/^    RED   \/* = 0 *\/,$/;"	e	enum:cores
Segmenta     o	doc/planejamento.tex	/^\\end{itemize}$/;"	s
TRUE	imagem.h	/^    TRUE  \/* = 1 *\/$/;"	e	enum:bool
UNAME_S	Makefile	/^UNAME_S := $(shell uname -s)$/;"	m
X0	graphic.c	45;"	d	file:
Y0	graphic.c	46;"	d	file:
_CORES_H	cores.h	12;"	d
_GRAPHIC_C	graphic.c	11;"	d	file:
_GRAPHIC_C	graphic.c	438;"	d	file:
_GRAPHIC_H	graphic.h	18;"	d
_IMAGEM_H	imagem.h	33;"	d
_IO_H	io.h	15;"	d
_MAIN_H	main.h	15;"	d
_iCor	graphic.c	/^static int        _iCor   = 0;      \/* indice de uma cor no vetor cores *\/  $/;"	v	file:
_imgOriginal	graphic.c	/^static Imagem   *_imgOriginal = NULL; \/* imagem original, nao e alterada *\/$/;"	v	file:
_iniRegioes	graphic.c	/^static CelRegiao *_iniRegioes = NULL;$/;"	v	file:
_limiar	graphic.c	/^static int        _limiar = LIMIAR; \/* limiar inicial usada para determinar$/;"	v	file:
_tela	graphic.c	/^static Imagem          *_tela = NULL; \/* imagem corrente *\/$/;"	v	file:
bool	imagem.h	/^enum bool $/;"	g
borda	imagem.h	/^    Bool            borda; \/* indica se a regiao e ou nao de borda *\/$/;"	m	struct:celRegiao
carregueImagemPPM	io.c	/^carregueImagemPPM(char *nomeArquivo)$/;"	f
celPixel	imagem.h	/^struct celPixel $/;"	s
celRegiao	imagem.h	/^struct celRegiao $/;"	s
col	imagem.h	/^    int        col, lin; \/* [lin][col] e a posicao do pixel *\/$/;"	m	struct:celPixel
copieImagem	imagem.c	/^copieImagem(Imagem *destino, Imagem *origem)$/;"	f
copiePonteirosRegiao	graphic.c	/^copiePonteirosRegiao(Imagem *destino, Imagem *origem)$/;"	f	file:
cor	imagem.h	/^    Byte           cor[3]; \/* cor dos pixels na regiao *\/$/;"	m	struct:celRegiao
cor	imagem.h	/^    Byte cor[3];      $/;"	m	struct:pixel
cores	cores.h	/^Byte cores[NUM_CORES+1][3]=$/;"	v
cores	imagem.h	/^enum cores$/;"	g
estaDentro	imagem.c	/^int estaDentro(int linha, int coluna, int height, int width) {$/;"	f
freeImagem	imagem.c	/^freeImagem(Imagem *img)$/;"	f
freeRegioes	imagem.c	/^freeRegioes(CelRegiao *iniRegioes)$/;"	f
getPixel	imagem.c	/^getPixel(Imagem *img, int col, int lin)$/;"	f
graveImagem	main.c	/^graveImagem(Imagem *img)$/;"	f
graveImagemPPM	io.c	/^graveImagemPPM(char *nomeArquivo, Imagem *img)$/;"	f
height	imagem.h	/^    int    height; \/* no. de linhas  (height\/altura) da imagem em pixels *\/$/;"	m	struct:imagem
imagem	imagem.h	/^struct imagem $/;"	s
iniPixels	imagem.h	/^    CelPixel   *iniPixels; \/* ponteiro para a lista de pixels na regiao *\/$/;"	m	struct:celRegiao
lin	imagem.h	/^    int        col, lin; \/* [lin][col] e a posicao do pixel *\/$/;"	m	struct:celPixel
luminosidadePixel	imagem.c	/^luminosidadePixel(Imagem *img, int col, int lin)$/;"	f	file:
main	main.c	/^main(int argc, char *argv[])$/;"	f
mallocImagem	imagem.c	/^mallocImagem(int width, int height)$/;"	f
mallocSafe	imagem.c	/^mallocSafe(size_t nbytes)$/;"	f	file:
mostreUso	graphic.c	/^mostreUso()$/;"	f	file:
mostreUso	main.c	/^mostreUso(char *nomePrograma)$/;"	f	file:
myDisplay	graphic.c	/^myDisplay(void)$/;"	f	file:
myInit	graphic.c	/^myInit(int *argc, char *argv[], Imagem *tela, Imagem *imgOriginal,$/;"	f
myKeyboard	graphic.c	/^myKeyboard (unsigned char key, int mx, int my)$/;"	f	file:
myMouse	graphic.c	/^myMouse(int b, int s, int col, int lin)$/;"	f	file:
myReshape	graphic.c	/^myReshape(int col, int lin)$/;"	f	file:
nPixels	imagem.h	/^    int           nPixels; \/* no. de pixels na regiao *\/$/;"	m	struct:celRegiao
pinteImagem	imagem.c	/^pinteImagem(Imagem *img, Byte cor[])$/;"	f
pinteRegioes	imagem.c	/^pinteRegioes(Imagem *img, CelRegiao *iniRegioes, Bool borda)$/;"	f
pixel	imagem.h	/^    Pixel **pixel; \/* matriz height x width de pixels com os n√≠veis RGB  *\/$/;"	m	struct:imagem
pixel	imagem.h	/^struct pixel$/;"	s
pixelBorda	imagem.c	/^pixelBorda(Imagem *img, int limiar, int col, int lin)$/;"	f	file:
pixelsRegiao	imagem.c	/^pixelsRegiao(Imagem *img, int limiar, int col, int lin, CelRegiao *regiao)$/;"	f	file:
proxPixel	imagem.h	/^    CelPixel *proxPixel; \/* ponteiro para o proximo pixel *\/$/;"	m	struct:celPixel
proxRegiao	imagem.h	/^    CelRegiao *proxRegiao; \/* ponteiro para a proxima regiao *\/  $/;"	m	struct:celRegiao
quit	main.c	/^quit(Imagem *tela, Imagem *img, CelRegiao *iniRegioes)$/;"	f
regiao	imagem.h	/^    CelRegiao  *regiao; \/* ponteiro para a celula da regiao do pixel $/;"	m	struct:pixel
repinteRegiao	imagem.c	/^repinteRegiao(Imagem *img, int col, int lin, Byte cor[])$/;"	f
repinteRegioes	imagem.c	/^repinteRegioes(Imagem *img, CelRegiao *iniRegioes, int col, int lin, $/;"	f
segmenteImagem	imagem.c	/^segmenteImagem(Imagem *img, int limiar)$/;"	f
setPixel	imagem.c	/^setPixel(Imagem *img, int col, int lin, Byte cor[])$/;"	f	file:
width	imagem.h	/^    int     width; \/* no. de colunas (width\/largura) da imagem em pixels *\/$/;"	m	struct:imagem
